#include <DEM.hpp>

#include <WGS84toCartesian.hpp>
#include <delaunator.hpp>
#include <colourmanager.h>

using namespace std;

DEM::DEM(const string &ifname, const string &ofname, const int &x) {
    // Initialize the ColourManager
    ColourManager::Init_ColourManager();

    // Setting up the variables
    m_ifname = ifname;
    m_ofname = ofname;
    m_x = x;
}

DEM::~DEM() {}

void DEM::read(const string& filename) {
    ifstream f(filename);

	if (!f.is_open())
		std::cout << "\033[1;31mAn error occurred while opening the file " << filename << " \033[0m" << std::endl;
	
    else {
        // Map data_raw to store the raw read data
        std::map <std::pair<double, double>, double> data_raw;

        // Reading the file
        for(std::string line; std::getline(f, line);) {
            // Make a stream for each line
            istringstream in(line);
            
            // Reading the coords in the line
            double latitude, longitude, z;
            in >> latitude >> longitude >> z;

            // Projection with the Mercator projection
            array<double, 2> result{wgs84::toCartesian({48.4029251,-4.4690661}, {latitude, longitude})};
            
            // Raw data storage
            data_raw.insert(make_pair(make_pair(result[0], result[1]), z));
        }

        // Statistics on the raw data
        Stats s_raw = statistics(data_raw);

        // Shifting the raw data to have lighter data if necessary
        if (s_raw.xmin != 0 or s_raw.ymin != 0) {
            std::map <std::pair<double, double>, double> data_shifted;
            for (const auto &i : data_raw) {
                data_shifted.insert(make_pair(make_pair(i.first.first-s_raw.xmin, i.first.second-s_raw.ymin), i.second));
                m_coords.push_back(i.first.first-s_raw.xmin);
                m_coords.push_back(i.first.second-s_raw.ymin);
            }
            m_data = data_shifted;
        }
        else 
            m_data = data_raw;

        // Setting up the statistics data
        xmin = 0.0;
        xmax = s_raw.xmax - s_raw.xmin;
        ymin = 0.0;
        ymax = s_raw.ymax - s_raw.ymin;
        zmin = s_raw.zmin;
        zmax = s_raw.zmax;

        // m_step computing
        m_step = (s_raw.xmax - s_raw.xmin)/m_x;

        // m_y computing according to m_x and the width of data
        m_y = (s_raw.ymax - s_raw.ymin)/m_step;

        // Creating the image according to m_x and m_y
        for (int i = 0; i < m_x; i++) {
            std::vector<Pixel *> vec;    
            for (int j = 0; j < m_y; j++) {
                Pixel* p = new Pixel();
                vec.push_back(p);
            }
            m_image.push_back(vec);
        }
    }

    // Closing the file
    f.close();
}

void DEM::triangulation(void) {
    // Triangulation of data with the Delaunay's triangulation
    delaunator::Delaunator d(m_coords);

    // Freeing up memory
    // m_coords.clear();
    // m_coords.shrink_to_fit();

    // Labelisation of the triangles
    for(std::size_t i = 0; i < d.triangles.size(); i+=3) {

        // Getting Triangle's points coordinates
        double xA = d.coords[2 * d.triangles[i]];
        double yA = d.coords[2 * d.triangles[i] + 1];
        double zA = m_data[std::make_pair(xA, yA)];

        double xB = d.coords[2 * d.triangles[i + 1]];
        double yB = d.coords[2 * d.triangles[i + 1] + 1];
        double zB = m_data[std::make_pair(xB, yB)];

        double xC = d.coords[2 * d.triangles[i + 2]];
        double yC = d.coords[2 * d.triangles[i + 2] + 1];
        double zC = m_data[std::make_pair(xC, yC)];      
        
        // Creating the triangle which have to be labelized
        Triangle T(xA, yA, zA, xB, yB, zB, xC, yC, zC);

        // Getting min and max labels depending on the three vextex coordinates
        std::pair <int, int> mnmx = std::minmax({xA/x_labelizator, xB/x_labelizator, xC/x_labelizator});
        std::pair <int, int> mnmy = std::minmax({yA/y_labelizator, yB/y_labelizator, yC/y_labelizator});

        // Testing if the triangle is not artificially generated by the Delaunay's triangulation with a concave hull method
        if (concave_hull(T, m_alpha)) {

            // Ranging from min to max labels on x and y axes
            for (int j = mnmx.first; j <= mnmx.second; j++) {
                for (int k = mnmy.first; k <= mnmy.second; k++) {

                    // Searching label in the m_trangles map
                    std::pair<int, int> label = std::make_pair(j, k);
                    auto it = m_triangles.find(label);

                    // If the label is already in the map, pushing back the triangle
                    if (it != m_triangles.end())
                        m_triangles[label].push_back(T);

                    // Else creating the entry in the map
                    else {
                        std::vector<Triangle> v = {T};
                        m_triangles.insert(std::make_pair(label, v));
                    }
                }
            }
        }
    }
}

void DEM::process(void) {

    // ColorMap creating wwith custom colours
    ColourManager manager(zmin, zmax);
    ColourMap cmap("cmap");
    cmap.addColour(142, 68, 173,1.0);   // Wisteria
    cmap.addColour(41, 128, 185, 1.0);  // Belize Hole
    cmap.addColour(46, 204, 113, 1.0);  // Nephritis
    cmap.addColour(241, 196, 15, 1.0);  // Sun Flower
    cmap.addColour(230, 126, 34, 1.0);  // Carrot
    cmap.addColour(235, 59, 90,1.0);    // Crimson

    // Setting the ColourMap
    ColourManager::setCurrentColourMap(cmap);
    Colour c = manager.getInterpolatedColour(zmin);

    // Processing pixels of m_image
    Point M;
    float R, G, B;
    for (std::size_t i = 0; i < m_x; i++) {
        for (std::size_t j = 0; j < m_y; j++) {

            // Setting the coordinates of the pixel in the data
            M.m_x = xmin + i*m_step;
            M.m_y = ymin + j*m_step;

            // Get triangles by label
            std::pair<int, int> label(M.m_x/x_labelizator, M.m_y/y_labelizator);
            auto it = m_triangles.find(label);

            if (it != m_triangles.end()) {
                for(std::size_t k = 0; k < it->second.size(); k++) {

                    // Getting the Triangle
                    Triangle T = it->second[k];

                    // Finding in which triangle is the pixel
                    if (isPointInTriangle(M, T)) {

                        // Setting the colour of the pixel in the image
                        c = manager.getInterpolatedColour(T.z);
                        R = c.getR();
                        G = c.getG();
                        B = c.getB();
                        
                        m_image[i][j]->setRGB(R, G, B);
                        
                        // HSV getting
                        float H, S, V;
                        m_image[i][j]->getHSV(H, S, V);

                        // Hill shading
                        V *= std::pow((m_sun.dot(T.n)+1)/2, 0.3);

                        // Constrast and luminosity adjusting
                        V = 1 / (1 + std::exp(-10 * (V - 0.5)));
                        V = std::min(1.0, V + 0.4);

                        m_image[i][j]->setHSV(H, S, V);
                    }
                }
            }
        }
    }
}

void DEM::save(string filename, int x, int y) {
    ofstream f(filename);

	if (!f.is_open())
		cout << "An error occurred while saving the file" << filename << endl;
	
    else {
        // Header of the PPM file
        f << "P6" << endl;
        f << "# Digital Elevation Model created with create_raster" << endl;
        f << m_y << " " << m_x << endl;
        f << "255" << endl;

        // File writing
        for (int i = 0; i < m_x; i++) {
            for (int j = 0; j < m_y; j++) {
                f << *(m_image[i][j]);
            }
        }
    }
    f.close();
}